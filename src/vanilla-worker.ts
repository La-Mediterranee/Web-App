declare var self: ServiceWorkerGlobalScope;
import { build, files, timestamp } from '$service-worker';

/*
	`build` is an array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build)
	`files` is an array of URL strings representing the files in your static directory, or whatever 
	directory is specified by config.kit.files.assets 
*/
console.log(files);
console.log(build);

interface ChacheNames {
	readonly pages: string;
	readonly assets: string;
	readonly offline: string;
}

const OFFLINE_VERSION = '1'; // `${timestamp}`;
const exclude: string[] = ['offline'];

const cacheNames: ChacheNames = {
	offline: `offline_v${OFFLINE_VERSION}`,
	pages: `pages_v${OFFLINE_VERSION}`,
	assets: `assets_${OFFLINE_VERSION}`
};

const toCache = exclude.map((path) => build.filter((file) => !file.includes(path)))[0];
console.log(toCache);
const cached = new Set(build);
const ASSETS_CACHE = `cache${timestamp}`;
const OFFLINE_URL = '/offline.html';
const SVELTE_OFFLINE_URL = '/offline';

self.addEventListener('install', (event) => {
	event.waitUntil(
		(async () => {
			const cache = await caches.open(ASSETS_CACHE);
			await cache.addAll(build);
			self.skipWaiting();
		})()
	);

	event.waitUntil(
		(async () => {
			console.log('[ServiceWorker] Pre-caching offline page');
			const cache = await caches.open(cacheNames.offline);
			await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));
			self.skipWaiting();
		})()
	);
});

self.addEventListener('activate', (event) => {
	console.log('[ServiceWorker] Activating new service worker...');
	const cacheWhitelist = [ASSETS_CACHE, cacheNames.offline];

	event.waitUntil(
		(async () => {
			// Enable navigation preload if it's supported.
			if ('navigationPreload' in self.registration) {
				await self.registration.navigationPreload.enable();
			}
		})()
	);

	event.waitUntil(
		caches.keys().then((keys) => {
			// delete old caches
			return Promise.all(
				keys.map((cacheName) => {
					if (cacheWhitelist.indexOf(cacheName) === -1) {
						console.log('[ServiceWorker] Removing old cache', cacheName);
						return caches.delete(cacheName);
					}
				})
			);
		})
	);

	self.clients.claim();
});

self.addEventListener('fetch', (event) => {
	const request = event.request;

	if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

	const url = new URL(request.url);

	// don't try to handle e.g. data: URIs
	if (!url.protocol.startsWith('http')) return;

	// ignore dev server requests
	if (url.hostname === self.location.hostname && url.port !== self.location.port) return;

	console.log('[ServiceWorker] ' + request.mode);

	// Offline Page
	if (request.mode === 'navigate' || url.pathname.includes('pages')) {
		// We only want to call event.respondWith() if this is a navigation request
		// for an HTML page.
		event.respondWith(
			(async () => {
				try {
					// First, try to use the navigation preload response if it's supported.
					const preloadResponse = await event.preloadResponse;
					if (preloadResponse) {
						return preloadResponse;
					}

					const networkResponse = await fetchAndCache(event.request);
					return networkResponse;
				} catch (err) {
					console.log('Fetch failed; returning offline page instead.', err);
					return getOfflinePage();
				}
			})()
		);
	}
	// always serve static files and bundler-generated assets from cache
	else if (url.host === self.location.host && cached.has(url.pathname)) {
		event.respondWith(
			(async () => {
				try {
					const cache = await caches.open(ASSETS_CACHE);
					const match = await cache.match(event.request);
					if (match) {
						return match;
					}
				} catch (error) {
					console.error(error);
				}

				return fetchAndCache(event.request);
			})()
		);
		return;
	}
});

/**
 * Fetch the asset from the network and store it in the cache.
 * Fall back to the cache if the user is offline.
 */
async function fetchAndCache(request: Request) {
	const cache = await caches.open(ASSETS_CACHE);
	try {
		const response = await fetch(request);
		if (
			[0, 200].includes(response.status) &&
			request.method.toUpperCase() === 'GET' &&
			request.url.indexOf('chrome-extension') === -1 &&
			response.type === 'basic'
		)
			cache.put(request, response.clone());
		return response;
	} catch (err) {
		// const cache = await caches.open(cacheNames.offline);
		// if (cache) return cache.match('offline.html');
		// throw err;
		return getOfflinePage();
	}
}

async function getOfflinePage() {
	const cache = await caches.open(cacheNames.offline).catch(console.error);
	// console.log(cache);
	const chachedResponse = await cache?.match(OFFLINE_URL).catch(console.error);
	// console.log(chachedResponse);
	return chachedResponse as Response;
}
///////////////////////////////
////// Push Notification //////
///////////////////////////////
const applicationServerPublicKey =
	'BH8-hIchXKMI6AKSee8gD0hhPThRqaEhIEtMJwcTjEQhiOKdG-_2tTIO-6hOAK4kwg5M9Saedjxp4hVE-khhWxY';

function urlB64ToUint8Array(base64String: string) {
	const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
	const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');

	const rawData = window.atob(base64);
	const outputArray = new Uint8Array(rawData.length);

	for (let i = 0; i < rawData.length; ++i) {
		outputArray[i] = rawData.charCodeAt(i);
	}
	return outputArray;
}

self.addEventListener('push', function (event) {
	console.log('[Service Worker] Push Received.');
	console.log(`[Service Worker] Push had this data: "${event.data?.text()}"`);

	const title = 'Push Codelab';
	const options = {
		body: 'Yay it works.',
		icon: 'images/icon.png',
		badge: 'images/badge.png'
	};

	event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', function (event) {
	console.log('[Service Worker] Notification click Received.');

	const notification = event.notification;
	const primaryKey = notification.data.primaryKey;

	notification.close();
	console.log('Closed notification: ' + primaryKey);

	if (event.action === 'close') {
		notification.close();
	} else {
		// self.clients.openWindow('http://www.example.com');
		event.waitUntil(self.clients.openWindow('https://developers.google.com/web/'));
		notification.close();
	}
});

self.addEventListener('pushsubscriptionchange', async (event) => {
	const evt = event as PushSubscriptionChangeEvent;

	console.log("[Service Worker]: 'pushsubscriptionchange' event fired.");
	const applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);

	async function newSub() {
		const newSubscription = await self.registration.pushManager.subscribe({
			userVisibleOnly: true,
			applicationServerKey: applicationServerKey
		});

		console.log('[Service Worker] New subscription: ', newSubscription);
	}

	evt.waitUntil(newSub());
});
