// import workbox
// importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');
// const { routing, strategies, precaching, setConfig, expiration, googleAnalytics, core } = workbox;
// const { registerRoute, NavigationRoute } = routing;
// const { precacheAndRoute } = precaching;
// const { NetworkOnly, NetworkFirst } = strategies;

declare var self: ServiceWorkerGlobalScope;
/*
 *	`build` is an array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build)
 *	`files` is an array of URL strings representing the files in your static directory, or whatever
 *	directory is specified by config.kit.files.assets
 */
import { build, files, timestamp } from '$service-worker';

import * as googleAnalytics from 'workbox-google-analytics';

import { openDB } from 'idb';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute, setCatchHandler } from 'workbox-routing';
import { enable as navigationPreloadEnable } from 'workbox-navigation-preload';
import { setCacheNameDetails, skipWaiting, clientsClaim } from 'workbox-core';
import { NetworkOnly, NetworkFirst, StaleWhileRevalidate } from 'workbox-strategies';

import { SHOP_URL } from '$utils/constants';

import type { DBSchema, StoreNames, IDBPDatabase } from 'idb';
import type { RouteMatchCallbackOptions, RouteHandlerCallbackOptions } from 'workbox-core';

interface ChacheNames {
	/** generated js and css files from sveltekit */
	readonly pages: string;
	/** files in the static folder from sveltekit */
	readonly static: string;
	/** images from cdns,storages,etc. saved in IndexedDB */
	readonly images: string;
	/** offline Page */
	readonly offline: string;
}

interface StoragePaths {
	readonly root: string;
	readonly jsScope: string;
	readonly cssScope: string;
	readonly imgScope: string;
	readonly offlinePage: string;
}

interface Entries {
	url: string;
	revision: string | null;
}

const OFFLINE_VERSION = '1'; // `${timestamp}`;
const exclude: string[] = ['offline'];

const cacheNames: ChacheNames = {
	images: `images_v${OFFLINE_VERSION}`,
	offline: `offline_v${OFFLINE_VERSION}`,
	pages: `pages_v${OFFLINE_VERSION}`,
	static: `static_${OFFLINE_VERSION}`
};

const toCache = exclude.map((path) => build.filter((file) => !file.includes(path)))[0];

let precachedFiles: string[] = [];
let basePaths: StoragePaths | null = null;
let imgExpDb: IDBPDatabase;
let currentImgDb: IDBPDatabase;

/**
 * Returns the registered offline page from the precache cache
 */
async function getOfflinePage(): Promise<Response> {
	const [cache] = await runAsync<Cache>(caches.open(cacheNames.offline));
	const chachedResponse = await cache
		?.match(basePaths?.offlinePage as RequestInfo)
		.catch(console.error);
	return chachedResponse as Response;
}

/**
 *  Respond to JS/CSS requests as quickly as possible with a cached response if available,
 *  falling back to the network request if it’s not cached.
 *  The network request is then used to update the cache.
 */
function routeAndCacheJsAndCSS(urls: RegExp) {
	return registerRoute(
		({ url }) => {
			if (!url.hostname.match(urls)) {
				return false;
			}
			return (
				url.pathname.match(/\.(?:js|css)/i) &&
				precachedFiles.indexOf(url.pathname.split('?').shift() as string) === -1 &&
				precachedFiles.indexOf(url.href.split('?').shift() as string) === -1
			);
		},
		new StaleWhileRevalidate({
			cacheName: cacheNames.pages
		})
	);
}

function cacheAndRoute(entries: Entries[]) {
	entries.forEach((entry) => {
		entry.url = `${basePaths?.root}/${entry.url}`;
		precachedFiles.push(entry.url);
	});

	return precacheAndRoute(entries, { ignoreURLParametersMatching: [/.*/] });
}

/**
 *  Respond to images requests as quickly as possible with a cached response if available,
 *  falling back to the network request if it’s not cached.
 *  The network request is then used to update the cache.
 *  Limit cache usage to [rotationCount] images with LRU updating logic.
 *  Limit images validity to [daysDuration].
 */
async function routeAndCacheProductImages({ rotationCount = 200, daysDuration = 30 }) {
	// const currentImgDb = await openDB(cacheNames.images, 1);
	// const imgExpDb = await openDB(`${cacheNames.images}-exp`, 1);
	const imgDbs = [currentImgDb, imgExpDb];
	const storeName = 'keyvaluepairs';

	const save = async (url: URL, blob: Promise<Blob>) => {
		const key = `${url}`;
		const timestamp = Date.now();

		const size = (await currentImgDb.getAllKeys(storeName)).length;

		if (size >= rotationCount && rotationCount > 0) {
			const keys = await currentImgDb.getAllKeys(storeName);
			const outdatedItemKey = keys[0];
			imgDbs.forEach((db) => db.delete(storeName, outdatedItemKey));
			return outdatedItemKey;
		}

		imgExpDb.add(storeName, timestamp, key);

		return currentImgDb.add(storeName, blob, key);
	};

	const read = async (url: URL): Promise<Blob | null> => {
		let result = null;

		const key = `${url}`;
		const [blob, timestamp] = await Promise.all([
			currentImgDb.get(storeName, key),
			imgExpDb.get(storeName, key)
		]);

		if ((timestamp as number) + daysDuration * 24 * 60 * 60 * 1000 < Date.now()) {
			imgDbs.forEach((db) => db.delete(storeName, key));
		} else {
			result = blob as Blob;
		}

		return result;
	};

	registerRoute(
		({ url }) => {
			return (
				url.hostname.match(/.*(?:la-mediterranee)\.at/) &&
				url.pathname.match(/.*\.(?:png|gif|jpg|jpeg|webp|svg)/) &&
				url.search.match(/impolicy=product/) &&
				precachedFiles.indexOf(url.pathname.split('?').shift() as string) === -1 &&
				precachedFiles.indexOf(url.href.split('?').shift() as string) === -1
			);
		},
		async ({ url }) => {
			try {
				const response = await fetch(url.href);
				save(url, response.clone().blob());
				return response;
			} catch (error) {
				const blob = await read(url);
				// if (blob) {
				// 	return new Response(blob);
				// }
				return new Response(blob);
			}
		}
	);
}

async function runAsync<T>(promise: Promise<T>): Promise<[T | null, any | null]> {
	try {
		const data = await promise;
		return [data, null];
	} catch (error) {
		console.error(error);
		return [null, error];
	}
}

/**
 * Removes existing live caches.
 * This is to be called on swLogicInit only.
 */
async function resetCaches() {
	const keys = await caches.keys();
	// delete old caches
	// for (const property in cacheNames) {
	// 	const key = property as keyof ChacheNames;
	// 	if (caches.has(cacheNames[key])) {
	// 		//@ts-ignore
	// 		caches.delete(caches[key]);
	// 	}
	// }
	return Promise.all(
		keys.map((cacheName) => {
			if (Object.values(cacheNames).indexOf(cacheName) === -1) {
				console.log('[ServiceWorker] Removing old cache', cacheName);
				return caches.delete(cacheName);
			}
		})
	);
}

const routeResourcesNetworkFirst = () => {
	const matcher = ({ url }: RouteMatchCallbackOptions) => {
		if (!url.hostname.match(SHOP_URL) || url.pathname.match(/__SYSTEM__/)) {
			return false;
		}

		return url.pathname.indexOf('ResourceController-') !== -1;
	};

	const handler = async (eventRequest: RouteHandlerCallbackOptions) => {
		try {
			return await fetch(eventRequest.request);
		} catch (error) {
			const cache = await caches.open(cacheNames.offline);
			return cache.match(eventRequest.request, { ignoreSearch: true }) as Promise<Response>;
		}
	};

	registerRoute(matcher, handler);
};

/**
 * Route requests of type 'navigate' with a NetworkOnly strategy, fallback to offline page if
 * network fail.
 */
const routePagesOrServeOffline = ({ daysDuration = 7, isNavigationEnabled = false }) => {
	let strategy: NetworkFirst | NetworkOnly;

	if (isNavigationEnabled) {
		strategy = new NetworkFirst({
			cacheName: 'pages',
			plugins: [
				new ExpirationPlugin({
					maxAgeSeconds: daysDuration * 24 * 60 * 60
				})
			]
		});
	} else {
		strategy = new NetworkOnly();
	}

	// match url that contains .html or no extension at all
	const matcher = ({ url, request }: RouteMatchCallbackOptions) =>
		request.mode === 'navigate' && url.hostname.match('');

	const handler = async (eventRequest: RouteHandlerCallbackOptions) => {
		try {
			return await strategy.handle(eventRequest);
		} catch (e) {
			return await getOfflinePage();
		}
	};

	registerRoute(matcher, handler);
};

function init(paths: StoragePaths, caching: { images: Object; offline: Object }) {
	basePaths = paths;

	// workbox.setConfig({ debug: false });

	openDB(cacheNames.images, 1, {
		upgrade(db) {
			db.createObjectStore('keyvaluepairs');
		}
	}).then((db) => {
		imgExpDb = db;
	});

	openDB(`${cacheNames.images}-exp`, 1, {
		upgrade(db) {
			db.createObjectStore('keyvaluepairs');
		}
	}).then((db) => {
		imgExpDb = db;
	});

	// localforage.config({ name: cacheNames.images });
	// localforage.createInstance({ name: `${cacheNames.images}-exp` });

	resetCaches();

	navigationPreloadEnable();

	setCacheNameDetails({
		prefix: 'shop',
		postfix: '',
		precache: 'assets'
	});

	skipWaiting();
	clientsClaim();

	googleAnalytics.initialize();

	setCatchHandler(async () => {
		return new Response(null, { status: 404 });
	});

	cacheAndRoute([
		...build.map((asset) => {
			console.log(`=== $service-worker build === ${asset}`);
			return {
				url: asset,
				revision: null
			} as Entries;
		}),
		...files.map((file) => {
			console.log(`=== $service-worker files === ${file}`);
			return {
				url: file,
				revision: `${timestamp}`
			} as Entries;
		})
	]);
	routePagesOrServeOffline(caching.offline);
	routeResourcesNetworkFirst();
	routeAndCacheJsAndCSS(/la-mediterranee\.at/);
	routeAndCacheProductImages(caching.images);
}

// init()
